#include "Cipher.h"

#include <time.h>
#include <windows.h>
#include <math.h>

#include <string>


char* GenerateKey(int length)
{
	char* buffer = (char*)malloc(length);
	srand((unsigned int)time(0));
	for (int i = 0; i < length; i++)
		buffer[i] = rand() * 255;
	return buffer;
}

char* EncryptWithKey(char* input, char* key, int inputLength, int keyLength, char** outputKey) {
	char* xoredInput = XORInputKey(input, key, inputLength, keyLength);
	char* encoded = Base64Encode(xoredInput, inputLength);
	*outputKey = Base64Encode(key, keyLength);
	free(xoredInput);

	return encoded;
}
char* DecryptWithKey(char* input, char* key, int* outputLength){
	int inputLength, keyLength;
	char* decodedKey = Base64Decode(key, &keyLength);
	char* decodedInput = Base64Decode(input, &inputLength);

	char* output = XORInputKey(decodedInput, decodedKey, inputLength, keyLength);
	free(decodedInput);
	free(decodedKey);

	*outputLength = inputLength;

	return output;
}


char* XORInputKey(char* input, char* key, int inputLength, int keyLength)
{
	char* output = (char*)malloc(inputLength + 1);
	output[inputLength] = 0;
	for (int i = 0; i < inputLength; i++)
		output[i] = input[i] ^ key[i % keyLength];
	return output;
}

static char* hexTable = (char *)"0123456789ABCDEF";
static char* base64Table = (char*)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static inline bool is_base64(char c) {
	return (isalnum(c) || (c == '+') || (c == '/'));
}

char base64_index(char c) {
	int ret = 64;
	if (c >= 'A' && c <= 'Z') {
		ret = c - 'A';
	}
	else if (c >= 'a' && c <= 'z') {
		ret = c - 'a' + 26;
	}
	else if (c >= '0' && c <= '9') {
		ret = c - '0' + 52;
	}
	else if (c == '+') {
		ret = 62;
	}
	else if (c == '/') {
		ret = 63;
	}
	else {
		ret = 64;
	}
	return ret;
}

char* Base64Encode(char* input, int length)
{
	int nInputLen = length;
	int nOutputLen = (int)(round((double)nInputLen / 3) * 4);

	char* output = (char*)malloc(nOutputLen + 1);
	char* retOutput = output;
	output[nOutputLen] = '\0';
	int i, j;
	char char_array_3[3];
	char char_array_4[4];

	for (i = 0; i + 2 < nInputLen; i = i + 3)
	{
		*output++ = base64Table[(input[i] & 0xfc) >> 2];
		*output++ = base64Table[((input[i] & 0x03) << 4) + ((input[i + 1] & 0xf0) >> 4)];
		*output++ = base64Table[((input[i + 1] & 0x0f) << 2) + ((input[i + 2] & 0xc0) >> 6)];
		*output++ = base64Table[input[i + 2] & 0x3f];
	}

	if (i != nInputLen) {
		for (j = 0; j < nInputLen - i; j++)
			char_array_3[j] = input[j + i];

		for (j; j < 3; j++)
			char_array_3[j] = '\0';

		char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
		char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
		char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);

		for (j = 0; (j <= nInputLen - i); j++)
			*output++ = base64Table[char_array_4[j]];

		while ((j++ <= 3))
			*output++ = '=';
	}



	return retOutput;
}

char* Base64Decode(char* input, int* outputLength)
{
	int nInputLen = strlen(input);
	if ((nInputLen % 4) != 0)
		return NULL;

	int nOutputLen = nInputLen * 3 / 4;

	char* output = (char*)malloc(nOutputLen + 1);
	char* retOutput = output;
	output[nOutputLen] = '\0';
	int i = 0;
	int	j = 0;
	int in_ = 0;
	char char_array_3[3];
	char char_array_4[4];

	*outputLength = 0;

	for (i = 0; i < nInputLen; i = i + 4)
	{
		if (!is_base64(input[i]) || !is_base64(input[i + 1]) || !is_base64(input[i + 2]) || !is_base64(input[i + 3]))
			break;

		for (j = 0; j < 4; j++)
			char_array_4[j] = base64_index(input[i+j]) & 0xff;

		*output++ = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
		*output++ = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
		*output++ = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
		*outputLength += 3;
	}

	if (i != nInputLen) {
		for (j = 0; j < 4; j++)
			char_array_4[j] = base64_index(input[i+j]) & 0xff;

		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
		char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
		char_array_3[2] = 0;

		for (j = 0; j < 3; j++) {
				*output++ = char_array_3[j];
				if (char_array_3[j] != 0) {
					*outputLength += 1;
				}
		}
	}

	return retOutput;
}


char* URLEncode(char* input, int length)
{
	int nInputLen = length;
	int nOutputLen = nInputLen * 3;

	char* output = (char*)malloc(nOutputLen + 1);
	char* retOutput = output;
	output[nOutputLen] = '\0';

	for (int i = 0; i < nInputLen; i++)
	{
		*output++ = '%';
		*output++ = hexTable[(input[i] & 0xF0) >> 4];
		*output++ = hexTable[(input[i] & 0x0F)];
	}

	return retOutput;
}

char* URLDecode(char* input, int* outputLength)
{
	int nInputLen = strlen(input);
	if ((nInputLen % 3) != 0)
		return NULL;
	int nOutputLen = nInputLen / 3;
	*outputLength = nOutputLen;
	char* output = (char*)malloc(nOutputLen + 1);
	output[nOutputLen] = '\0';

	char* workingInput = input;
	char* retOutput = output;

	for (int i = 0; i < nOutputLen; i++)
	{
		workingInput++; // dispose of '%'
		char charValue = 0;
		char working = *workingInput++;
		char actual;
		for (actual = 0; actual < 16; actual++)
		{
			if (hexTable[actual] == working)
				break;
		}
		charValue += (actual << 4);
		working = *workingInput++;
		for (actual = 0; actual < 16; actual++)
		{
			if (hexTable[actual] == working)
				break;
		}
		charValue += actual;
		*output++ = charValue;
	}

	return retOutput;
}